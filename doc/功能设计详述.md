
### 反应器与回调器

事件反应类型包括读、写、连接、关闭或异常等。
Linux下，常见的描述符大致有四类，分别是TCP套接字、管道符、UDP套接字、普通文件套接字。其中前两种是面向连接的描述符，后两种是面向非连接的描述符，本处理暂只支持面向连接的描述符。
通过 Linux epoll 多路复用模型对描述符事件进行处理。
事件反应器只作简单的读、写及连接与关闭等，具体的业务处理由事件回调器完成。
事件回调器主要针对事件反应器的读写事件及因循环发生的定时器事件进行回调处理。

----
### 信号处理

对一些可能会影响到进程启动或进程运行的信号进行忽略处理。
利用 SIGALRM 信号的定时机制。
重定义 SIGINT 的信号处理句柄；

----
### 心跳

简单的通过 epoll 的超时来实现一个伪定时器，心跳在定时器回调事件中实现。
子进程定时向守护进程发送心跳，后者以此作为根据来判断子进程服务连接是否丢失。
通过检测心跳来对子进程服务进行守护。在判断某个子进程连接丢失后，守护进程会重新拉起该子进程。

----
### 系统服务可配置与发现

配置驱动服务，指定义系统服务并基于配置实现服务发现。
系统服务分为父进程、子进程、本地连接和本地监听共四种。子进程通过父进程创建，本地连接与父进程共享一个进程，本地连接传输的数据下放到子进程处理。本地监听成功后会创建一个子进程服务，客户端连接成功后均交由该子进程服务处理，即本地监听的事件回调也是下放至子进程中进行。父进程只作监听、连接、路由、转发、守护作用，不做具体的业务处理，可提高父进程作为守护进程的存活率。
各子进程服务之间相互独立，子进程之间、子进程与远程其他端之间的通信通过守护进程作中介传输。
系统通过服务的名称，在内部自己计算出一个整型id来标识此服务。每个子进程服务都保存有一份已开启服务的id列表，将消息发送给对应的id就可以完成进程间的通信。
每个服务松耦合，能够对自己的逻辑服务完全负责，且不会对其他服务造成影响。

----
### 类似 Windows 消息处理的用户服务回调

为使用者提供一个类似 Windows 的回调来编写业务，回调通过服务名称关联。

----
### 进程队列与线程队列

各进程根据情况创建并维护自己的进程队列，子进程之间的通信通过守护进程进行中间转发，减少通信的复杂度。
转发(守护)进程中，服务尽力从IO中获取数据，存入队列，等待转发。子进程中，将处理后等待发送的数据存入队列，等待发送。
每个子进程中，用户业务线程与IO线程分离，所以需要设置线程队列用于消息的生产与消费。

---
### 大文件传输

如果需要传输文件，需要自己控制文件的偏移。
该框架是短数据消息服务框架，文件传输时没有使用内存零拷贝技术。所以本框架并不适合做大数据的迁移，但不禁止这样做。
目前为止对一些文件的传输测试(10M, 20M, 50M, 100M, 300M)暂未出错过。

----
## 负载均衡

客户端/代理端与服务端之间可以提供基于连接池的服务，但考虑到消息流的顺序性，以及本框架并不是真正的微服务框架，所以框架并不提供客户端/代理端的负载均衡服务。如果需要，使用者可以自己实现。
如果客户端/代理端使用了负载均衡，那么服务端在返回数据时也是按负载均衡(框架提供)的方式进行发送的。

----
### 子进程杀灭

可以通过下发消息的方式杀死某个子进程(不过随后守护进程又会将该进程重新拉起)。
进程杀灭一般很少使用，目前只在测试情况下使用。

----
### 僵尸进程处理

某个子进程在无法执行服务后，可能仍会作为僵尸进程存在于系统中，这个时候守护进程有义务将此僵尸进程杀掉。

----
### 优雅退出

具体就是 Ctrl+C 时确保所有的堆栈都得到销毁，并且没有内存泄漏。

----
### 定制化客户端扩展

为了方便对每个描述符的维护和管理，并适时记录一些信息，将描述符封装入 EClient 结构中。
可以为 EClient 添加一些虚函数，如数据库处理函数或序列化反序列化函数，以便将 EClient 状态数据写入本地数据库或上传至远端服务器。

