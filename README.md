
## 结构说明
- 主要包括四个部分，分别是消息解析、消息定义、事件反应、事件处理。其文件结构如下:
	+ 消息解析
		+ rapidjson\
		+ raj.h
	+ 消息定义
		+ bic_type.h
		+ bic.h
		+ bic.cpp
	+ 事件反应
		+ eeclient.h
		+ eeclient.cpp
		+ eehandler.h
		+ eehandler.cpp
	+ 事件处理
		+ eemodule.h
		+ eemodule.cpp
  另外还有一些辅助文件。
- 消息解析
	+ 为方便网络传输，这里通过 json 的方式对信息或数据进行序列化或结构化；
	+ json 使用开源的 rapidjson, 不会生成额外的依赖库；
	+ 为了方便使用，对 rapidjson 进行简单的模板化封装。
- 消息定义
	+ 每种消息采用 class 定义，名称为 BIC_??? 。消息类内成员使用 rapidjson 进行序列化或结构化；
	+ 从应用层角度看，消息一共分成两层，分别是自定义信息头和消息体，后者又包括消息头和有效荷载体。
		+ 为解决 tcp 传输处理过程中的一些问题，定义了自定义信息头，其内容包括版本号，消息体长度，
		  消息校验值等内容；
		+ 为了方便消息的定向传输及消息类型获取，将消息体分成了两个部分，分别是消息头和有效荷载体。
		  消息头主要定义了消息的流向、类型和诞生时间，而有效荷载体则定义具体的业务内容；
	+ 整个消息包结构如下(使用 json 表示):
		```json
		Packet: {
			NegoHeader: {
				// ...
			},
			BIC_MESSAGE: {
				BIC_HEADER : {
					// ...
				},
				BIC_PAYLOAD : {
					// ...
				}
			}
		}
		```
- 事件反应
	+ 事件类型包括读、写、连接、关闭或异常等；
	+ 通过 epoll 处理描述符(包括管道符和套接字)方式来处理相关事件并做出相应响应, epoll 通过
	  EpollEvHandler 类进行封装；
	+ 为了方便对每个描述符的维护和管理，并适时记录一些信息，将描述符封装入 EClient 结构中；
	+ linux 下，常见的描述符大致有四类，分别是 tcp套接字、管道符、udp套接字、普通文件套接字。
	  其中前两种是面向连接的描述符，后两种是面向非连接的描述符，本处理暂只支持面向连接的描述
	  符；
	+ 事件反应部分只作简单的读、写及连接与关闭等，具体的业务处理由事件处理部分完成；
	+ 事件反应还会对可能出现的僵尸进程进行处理；
- 事件处理
	+ 事件处理采用同步回调处理方式；
	+ 所负责的具体业务主要包括 消息校验、消息序列化及结构化、心跳、定时器、信号处理、fork 子
	  进程、进程杀灭、子进程重新调起等；
	+ 具体见功能说明；

## 功能说明
为便于描述，将下发策略的远程服务端称为策略端，本地守护子进程服务的进程称为守护端，用于示例的
两个子进程服务分别称为魔偶甜点端和机关傀儡端。
- 消息校验
	+ 对消息体部分(BIC_MESSAGE)进行校验；
	+ 使用较为常用的 crc32 作为校验方法；
	+ 因为对 crc32 校验原理不是太了解，所以校验方式是对接收数据重新计算 crc32，将结果进行比对；
- 消息序列化及结构化
	+ 调用 bic.h 文件中定义的消息类方法对消息进行处理；
- 心跳
	+ 方式: 客户端主动发送心跳，服务端通过对自己所负责的客户端进行定期检查来判断连接是否丢失；
	+ 这种方式可以减少一次消息传输，且处理起来也较为简单；
	+ 具体就是魔偶甜点端和机关傀儡端向守护端发送心跳，守护端向策略端发送心跳；	
- 定时器
	+ 通过设置 epoll 超时实现伪定时器；
	+ 也可以通过异步触发 epoll 监控事件或其他方式来实现(真定时器)，但应用于该场景中情况比较
	  复杂，较难控制，不推荐；
- 信号处理
	+ 对于 SIGPIPE 进行忽略处理；
	+ 为了能够优雅的杀死子进程，定义了 SIGALRM 进行处理；
	+ 为了方便子进程的重新调起，重定义了 SIGINT 的处理方式(当然，也可以采用其他信号)；
	+ 当前还对实时队列信号([SIGRTMIN, SIGRTMAX])进行了屏蔽处理，但发现毫无必要，后续可
	  将其去掉；
	+ 对于具体的服务线程，后续可以对一些信号，如 SIGSEGV, SIGBUS 等进行屏蔽处理，但应该也没
	  有必要；
- fork 子进程和子进程重新调起
	+ 为了方便维护管理以及 fork 时对堆栈的处理，子进程重新调起和 fork 子进程使用同样的处理方
	  式；
	+ 具体就是守护端在一段时间内没有接收到来自魔偶甜点端或机关傀儡端的心跳后，会重新 fork 一
	  个进程并清空守护端历史遗留堆栈，方便后续为魔偶甜点或机关傀儡创建堆栈；
- 进程杀灭
	+ 可以通过下发消息的方式杀死某个子进程；
	+ 具体就是策略端将杀死机关傀儡端的消息发送给守护端，守护端再转给机关傀儡端，后者收到此消
	  息后自毁(exit)；
	+ 可能还会存在不属于某个进程的子进程，但却是在该进程内启动的进程。对于这类进程，可通过信
	  号方式使其退出；
	+ 进程杀灭一般很少使用，目前只在测试情况下使用；

## 欠缺说明
- 对进程内启动进程的处理；
- 日志打印；
- 文件的归档和压缩；

## 注意说明
- 不支持多线程；
- 创建子进程时要注意对父进程历史遗留堆栈数据的清理；

## 版本说明

## 其他
